services:
  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: git_onchain_rewards
    # No need to expose 5432 to host; backend talks to db on the internal network
    volumes:
      - db_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d git_onchain_rewards"]
      interval: 5s
      timeout: 3s
      retries: 10

  hardhat-node:
    image: node:20-alpine
    working_dir: /app
    # Install deps inside the container to avoid macOS host FS quirks; then run the node
    command: sh -lc "npm ci && npx hardhat node --hostname 0.0.0.0"
    ports:
      - "8545:8545"
    volumes:
      - ..:/app
      - /app/node_modules
    healthcheck:
      test: ["CMD-SHELL", 'node -e "require(\"net\").createConnection(8545, \"127.0.0.1\").on(\"connect\",()=>process.exit(0)).on(\"error\",()=>process.exit(1)); setTimeout(()=>process.exit(1), 2000);"']
      interval: 5s
      timeout: 3s
      retries: 20

  deployer:
    image: node:20-alpine
    working_dir: /app
    environment:
      # If you want backend to verify on-chain, pass its public address here
      VERIFIER_PUBLIC: ${VERIFIER_PUBLIC:-}
      HARDHAT_RPC_URL: http://hardhat-node:8545
    depends_on:
      - hardhat-node
    command: sh -lc "npm ci && npx hardhat run scripts/deploy.js --network docker"
    volumes:
      - ..:/app

  backend:
    build:
      context: ..
      dockerfile: docker/backend.Dockerfile
      args:
        RUN_MODE: dev
    image: git-onchain-rewards/backend:local
    working_dir: /app/backend
    environment:
      DATABASE_URL: postgres://postgres:postgres@db:5432/git_onchain_rewards
      PORT: 4000
      # On-chain mode: use deployed address from deployer logs or override REGISTRY_ADDRESS
      RPC_URL: http://hardhat-node:8545
      REGISTRY_ADDRESS: ${REGISTRY_ADDRESS:-0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512}
      ENABLE_ONCHAIN: ${ENABLE_ONCHAIN:-}
      VERIFIER_PRIVATE_KEY: ${VERIFIER_PRIVATE_KEY:-}
      DEFAULT_PAYOUT_MODE: native
      DEFAULT_REWARD: "1000000000000000"
      # Evidence pinning
      IPFS_PROVIDER: ${IPFS_PROVIDER:-stub}
      WEB3_STORAGE_TOKEN: ${WEB3_STORAGE_TOKEN:-}
      PINATA_JWT: ${PINATA_JWT:-}
      # GitHub OAuth
      GITHUB_CLIENT_ID: ${GITHUB_CLIENT_ID:-}
      GITHUB_CLIENT_SECRET: ${GITHUB_CLIENT_SECRET:-}
      GITHUB_OAUTH_CALLBACK: ${GITHUB_OAUTH_CALLBACK:-http://localhost:4000/auth/github/callback}
      FRONTEND_ORIGIN: ${FRONTEND_ORIGIN:-http://localhost:5173}
      # Webhook config
      GITHUB_WEBHOOK_SECRET: ${GITHUB_WEBHOOK_SECRET:-}
      WEBHOOK_PUBLIC_URL: ${WEBHOOK_PUBLIC_URL:-}
      ALLOW_DEV_WEBHOOK: "true"
      ALLOW_DEV_BIND: "true"
    depends_on:
      db:
        condition: service_healthy
  # Use Dockerfile CMD (RUN_MODE=dev -> ts-node-dev). You can switch to prod by setting RUN_MODE: prod above.
  # command is intentionally omitted to respect image CMD
    ports:
      - "4000:4000"
    volumes:
      - ..:/app
      - /app/backend/node_modules
    healthcheck:
      test:
        - CMD-SHELL
        - >
          node -e "http=require('http'); http.get({host:'127.0.0.1', port: 4000, path: '/health'}, res => { process.exit(res.statusCode === 200 ? 0 : 1); }).on('error', () => process.exit(1)); setTimeout(() => process.exit(1), 2000);"
      interval: 5s
      timeout: 3s
      retries: 20

  frontend:
    image: node:20-alpine
    working_dir: /app/frontend
    environment:
      NEXT_PUBLIC_API_BASE: http://localhost:4000
      NEXT_PUBLIC_REGISTRY_ADDRESS: ${REGISTRY_ADDRESS:-}
    depends_on:
      backend:
        condition: service_healthy
    command: sh -lc "npm ci && npm run build && npm run start"
    ports:
      - "3000:3000"
    volumes:
      - ..:/app
      - /app/frontend/node_modules
    healthcheck:
      test:
        - CMD-SHELL
        - >
          node -e "http=require('http'); http.get({host:'127.0.0.1', port: 3000, path: '/'}, res => { process.exit(res.statusCode === 200 ? 0 : 1); }).on('error', () => process.exit(1)); setTimeout(() => process.exit(1), 2000);"
      interval: 5s
      timeout: 3s
      retries: 20

  blockscout:
    image: blockscout/blockscout:latest
    environment:
      MIX_ENV: prod
      SECRET_KEY_BASE: 6c6b2f8a6d7a4f9481e3d0ea1a9f0aee6c6b2f8a6d7a4f9481e3d0ea1a9f0aee
      DATABASE_URL: postgresql://postgres:postgres@blockscout-db:5432/blockscout
      ETHEREUM_JSONRPC_HTTP_URL: http://hardhat-node:8545
      ETHEREUM_JSONRPC_WS_URL: ws://hardhat-node:8545
      NETWORK_NAME: Local Hardhat
      CHAIN_ID: 31337
      API_ENABLED: "true"
      ENABLE_TXS_STATS: "false"
    depends_on:
      hardhat-node:
        condition: service_healthy
      blockscout-db:
        condition: service_started
      redis:
        condition: service_started
    ports:
      - "4001:4000"
    healthcheck:
      test:
        - CMD-SHELL
        - >
          node -e "http=require('http'); http.get({host:'127.0.0.1', port: 4000, path: '/'}, res => { process.exit(res.statusCode === 200 ? 0 : 1); }).on('error', () => process.exit(1)); setTimeout(() => process.exit(1), 2000);"
      interval: 15s
      timeout: 5s
      retries: 40

  otterscan:
    image: ghcr.io/otterscan/otterscan:latest
    environment:
      ETH_RPC_URL: http://hardhat-node:8545
    depends_on:
      hardhat-node:
        condition: service_healthy
    ports:
      - "4002:80"
    healthcheck:
      test:
        - CMD-SHELL
        - >
          node -e "http=require('http'); http.get({host:'127.0.0.1', port: 80, path: '/'}, res => { process.exit(res.statusCode === 200 ? 0 : 1); }).on('error', () => process.exit(1)); setTimeout(() => process.exit(1), 2000);"
      interval: 10s
      timeout: 5s
      retries: 30
  blockscout-db:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: blockscout
    volumes:
      - blockscout_db_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d blockscout"]
      interval: 5s
      timeout: 3s
      retries: 20

  redis:
    image: redis:7-alpine
    command: ["redis-server", "--save", "", "--appendonly", "no"]
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 20
  dapp:
    image: node:20-alpine
    working_dir: /app
    depends_on:
      backend:
        condition: service_healthy
    # Build the Vite app inside the container, then serve
    command: sh -lc "npm ci && npm run --prefix dapp build && node dapp/server.cjs"
    ports:
      - "5173:5173"
    volumes:
      - ..:/app
    healthcheck:
      test:
        - CMD-SHELL
        - >
          wget -qO- http://127.0.0.1:5173/ > /dev/null || exit 1
      interval: 5s
      timeout: 3s
      retries: 20

  # Optional: public tunnel for GitHub webhooks (Docker-only dev setup)
  # This starts a Cloudflare quick tunnel to the backend so GitHub can reach /webhook
  # Find the public URL in logs: `docker compose logs -f tunnel | grep -Eo "https://[-a-z0-9]+\.trycloudflare\.com" | head -n1`
  tunnel:
    image: cloudflare/cloudflared:latest
    depends_on:
      backend:
        condition: service_healthy
    command: tunnel --no-autoupdate --url http://backend:4000
    restart: unless-stopped

volumes:
  db_data:
  blockscout_db_data:
